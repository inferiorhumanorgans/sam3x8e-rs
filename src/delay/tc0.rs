use super::Delay;
use sam3x8e::TC0;
use hal::blocking::delay::{DelayMs, DelayUs};

const CLOCK_SPEED : u32 = 84_000_000; // 84 MHz
const DIVIDER : u32 = 8;
// const MILLI : u32 = 1_000;
const MICRO : u32 = 1_000_000;

pub struct TimerCounter0_0(pub TC0);

impl Delay<TimerCounter0_0> {
    pub fn new (timer: TimerCounter0_0) -> Self {
        Delay { source: timer }
    }

    /// Releases the TimerCouunter (TC0...TC2) resource
    pub fn free(self) -> TC0 {
        self.source.0
    }
}

impl DelayMs<u32> for Delay<TimerCounter0_0> {
    fn delay_ms(&mut self, ms: u32) {
        self.delay_us(ms * 1_000)
    }
}

impl DelayMs<u16> for Delay<TimerCounter0_0> {
    fn delay_ms(&mut self, ms: u16) {
        self.delay_ms(ms as u32);
    }
}

impl DelayMs<u8> for Delay<TimerCounter0_0> {
    fn delay_ms(&mut self, ms: u8) {
        self.delay_ms(ms as u32);
    }
}

impl DelayUs<u32> for Delay<TimerCounter0_0> {
    fn delay_us(&mut self, us: u32) {
        let cycles : u32 = us * ((CLOCK_SPEED / DIVIDER) / MICRO);

        let timer = &self.source.0;

        // Disable write protection
        timer.wpmr.write_with_zero(|w|
            w
            .wpen().clear_bit()
            .wpkey().passwd()
        );

        // let (cmr, rc, ccr, cv) = match self.source.channel {
        //     TimerChannel::Channel0 => (
        //         timer.cmr0_wave_eq_1(),
        //         &timer.rc0,
        //         &timer.ccr0,
        //         &timer.cv0,
        //     ),
        // };

        // We should select a clock based on the duration of the delay
        // This is autogenerated but should be renamed
        // to something like cmr0_wave
        timer.cmr0_wave_eq_1().write_with_zero(|w|
            w

            // MCLK/2
            // .tcclks().timer_clock1()

            // MCLK/8
            .tcclks().timer_clock2()

            // MCLK/32
            // .tcclks().timer_clock3()

            // MCLK/128
            // .tcclks().timer_clock4()

            // SCLK - slow clock typically 32MHz
            // .tcclks().timer_clock5()
            .wave().set_bit()
            .wave().set_bit()
            .wavsel().up()
            .cpcstop().set_bit()
            .cpcdis().set_bit()
        );

        timer.rc0.write_with_zero(|w| unsafe { w.bits(cycles) });

        timer.ccr0.write_with_zero(|w|
            w
            // Enable Timer
            .clken().set_bit()
            .clkdis().clear_bit()
            // Start timer
            .swtrg().set_bit()
        );

        while timer.cv0.read().bits() < cycles {}

        timer.ccr0.write_with_zero(|w|
            w
            // Disable Clock
            .clken().clear_bit()
            // Disable timer
            .clkdis().set_bit()
        );
    }
}

impl DelayUs<u16> for Delay<TimerCounter0_0> {
    fn delay_us(&mut self, us: u16) {
        self.delay_us(us as u32)
    }
}

impl DelayUs<u8> for Delay<TimerCounter0_0> {
    fn delay_us(&mut self, us: u8) {
        self.delay_us(us as u32)
    }
}
