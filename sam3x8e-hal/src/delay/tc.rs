/*
 *    This file (src/delay/tc.rs) is part of sam3x8e-hal.
 *
 *    sam3x8e-hal is free software: you can redistribute it and/or modify
 *    it under the terms of the GNU Lesser General Public License as published
 *    by the Free Software Foundation, either version 3 of the License, or
 *    (at your option) any later version.
 *
 *    sam3x8e-hal is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public License
 *    along with sam3x8e-hal.  If not, see <https://www.gnu.org/licenses/>.
 */

use super::Delay;
use crate::pac::{TC0, TC1, TC2};
use crate::pmc::Clocks;
use hal::blocking::delay::{DelayMs, DelayUs};

const CLOCK_SPEED: u32 = 84_000_000; // 84 MHz
const DIVIDER: u32 = 8;
// const MILLI : u32 = 1_000;
const MICRO: u32 = 1_000_000;

macro_rules! timer_hal {
    ($timer_name:ident, $timer_source:ident, $reg_cmr:ident, $reg_rc:ident, $reg_ccr:ident, $reg_cv:ident) => {
        pub struct $timer_name(pub $timer_source);

        impl Delay<$timer_name> {
            pub fn new(source: $timer_name, clocks: Clocks) -> Self {
                Delay { source, clocks }
            }

            /// Releases the TimerCouunter (TC0...TC2) resource
            pub fn free(self) -> $timer_source {
                self.source.0
            }
        }

        impl DelayMs<u32> for Delay<$timer_name> {
            fn delay_ms(&mut self, ms: u32) {
                self.delay_us(ms * 1_000)
            }
        }

        impl DelayMs<u16> for Delay<$timer_name> {
            fn delay_ms(&mut self, ms: u16) {
                self.delay_ms(ms as u32);
            }
        }

        impl DelayMs<u8> for Delay<$timer_name> {
            fn delay_ms(&mut self, ms: u8) {
                self.delay_ms(ms as u32);
            }
        }

        impl DelayUs<u32> for Delay<$timer_name> {
            fn delay_us(&mut self, us: u32) {
                let cycles: u32 = us * ((CLOCK_SPEED / DIVIDER) / MICRO);

                let timer = &self.source.0;

                // Disable write protection
                timer
                    .wpmr
                    .write_with_zero(|w| w.wpen().clear_bit().wpkey().passwd());

                // We should select a clock based on the duration of the delay
                // This is autogenerated but should be renamed
                // to something like cmr0_wave
                timer.$reg_cmr().write_with_zero(|w| {
                    w
                        // MCLK/2
                        // .tcclks().timer_clock1()
                        // MCLK/8
                        .tcclks()
                        .timer_clock2()
                        // MCLK/32
                        // .tcclks().timer_clock3()
                        // MCLK/128
                        // .tcclks().timer_clock4()
                        // SCLK - slow clock typically 32MHz
                        // .tcclks().timer_clock5()
                        .wave()
                        .set_bit()
                        .wave()
                        .set_bit()
                        .wavsel()
                        .up()
                        .cpcstop()
                        .set_bit()
                        .cpcdis()
                        .set_bit()
                });

                timer.$reg_rc.write_with_zero(|w| unsafe { w.bits(cycles) });

                timer.$reg_ccr.write_with_zero(|w| {
                    w
                        // Enable Timer
                        .clken()
                        .set_bit()
                        .clkdis()
                        .clear_bit()
                        // Start timer
                        .swtrg()
                        .set_bit()
                });

                while timer.$reg_cv.read().bits() < cycles {}

                timer.$reg_ccr.write_with_zero(|w| {
                    w
                        // Disable Clock
                        .clken()
                        .clear_bit()
                        // Disable timer
                        .clkdis()
                        .set_bit()
                });
            }
        }

        impl DelayUs<u16> for Delay<$timer_name> {
            fn delay_us(&mut self, us: u16) {
                self.delay_us(us as u32)
            }
        }

        impl DelayUs<u8> for Delay<$timer_name> {
            fn delay_us(&mut self, us: u8) {
                self.delay_us(us as u32)
            }
        }
    };
}

// The SAM3X8E has three timer counter (TC) modules with three channels each

timer_hal!(TimerCounter0, TC0, cmr0_wave_eq_1, rc0, ccr0, cv0);
timer_hal!(TimerCounter1, TC0, cmr1_wave_eq_1, rc1, ccr1, cv1);
timer_hal!(TimerCounter2, TC0, cmr2_wave_eq_1, rc2, ccr2, cv2);

timer_hal!(TimerCounter3, TC1, cmr0_wave_eq_1, rc0, ccr0, cv0);
timer_hal!(TimerCounter4, TC1, cmr1_wave_eq_1, rc1, ccr1, cv1);
timer_hal!(TimerCounter5, TC1, cmr2_wave_eq_1, rc2, ccr2, cv2);

timer_hal!(TimerCounter6, TC2, cmr0_wave_eq_1, rc0, ccr0, cv0);
timer_hal!(TimerCounter7, TC2, cmr1_wave_eq_1, rc1, ccr1, cv1);
timer_hal!(TimerCounter8, TC2, cmr2_wave_eq_1, rc2, ccr2, cv2);
